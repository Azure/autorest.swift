@using System.Collections.Generic;
@using System.Linq;
@using System.Text;
@using System;
@using AutoRest.Core.Model
@using AutoRest.Core.Utilities
@using AutoRest.Swift
@using AutoRest.Swift.Model

@inherits AutoRest.Core.Template<AutoRest.Swift.Model.MethodSwift>
@WrapComment("// ", Model.Name + " " + Model.Description.ToSentence())
public class @(Model.CommandModelName) : BaseCommand {
@for (var i = 0; i < Model.URLParameters.Count; i++)
{
    var param = Model.URLParameters[i];
    <text>
    public var @($"{param.VariableName}") : @($"{param.VariableTypeDeclaration(param.IsRequired)}")
    </text>
}

@for(var i = 0; i < Model.QueryParameters.Count; i++) {
    var param = Model.QueryParameters[i];
    if("apiversion".Equals(param.VariableName, StringComparison.OrdinalIgnoreCase)) {
<text>
    public var @($"{param.VariableName}") : @($"{param.VariableTypeDeclaration(param.IsRequired)}") = "@($"{Model.ApiVersion}")"
</text>
    }else {
<text>
    public var @($"{param.VariableName}") : @($"{param.VariableTypeDeclaration(param.IsRequired)}")
</text>
    }
}

@for (var i = 0; i < Model.HeaderParameters.Count; i++)
{
    @EmptyLine
    var param = Model.HeaderParameters[i];
    <text>
    public var @($"{param.VariableName}") : String? {
        set {
            if newValue != nil {
                headerParameters["@($"{param.SerializedName}")"] = newValue!
            }else {
                headerParameters["@($"{param.SerializedName}")"] = nil
            }
        }
        get {
            if headerParameters.contains(where: { $0.key == "@($"{param.SerializedName}")" }) {
                return headerParameters["@($"{param.SerializedName}")"]
            }else {
                return nil
            }
        }
    }
    </text>
}

@if (Model.BodyParameter != null)
{
    var param = Model.BodyParameter;
    <text>
    public var @($"{param.VariableName}") :  @($"{param.VariableTypeDeclaration(false)}")
    </text>
}
@EmptyLine
    public override init() {
        super.init()
        self.method = "@(Model.HttpMethod)"
        self.isLongRunningOperation = @(Model.IsLongRunningOperation() ? "true" : "false")
        self.path = "@(Model.Url)"
        self.headerParameters = ["Content-Type":"@(Model.RequestContentType)"]
    }
@EmptyLine
    public override func preCall()  {
@for(var i = 0; i < Model.URLParameters.Count; i++) {
    var param = Model.URLParameters[i];
    <text>
        if self.@($"{param.VariableName}") != nil { pathParameters["{@($"{param.SerializedName}")}"] = String(describing: self.@($"{param.VariableName}")!) }
    </text>
    }
@for(var i = 0; i < Model.QueryParameters.Count; i++) {
    var param = Model.QueryParameters[i];
    var parameterKey = param.SerializedName;
    if("apiversion".Equals(param.VariableName, StringComparison.OrdinalIgnoreCase)) {
        parameterKey = "api-version";
    }
    <text>
        if self.@($"{param.VariableName}") != nil { queryParameters["@($"{parameterKey}")"] = String(describing: self.@($"{param.VariableName}")!) }
    </text>
}       
@if (Model.BodyParameter != null)
{
    var param = Model.BodyParameter;
<text>
    self.body = @($"{param.VariableName}")
</text>
}
}
@EmptyLine
@if (Model.IsBodyParameterTypeAnEnum()) {
    var param = Model.BodyParameter;
<text>
    public override func encodeBody() throws -> Data? {
        return Data = (@($"{param.VariableName}").rawValue.data(using: String.Encoding.utf8))!
    }
</text>
}else if (Model.BodyParameter != null)
{
    var param = Model.BodyParameter;
    <text>
    public override func encodeBody() throws -> Data? {
        let contentType = "@(Model.EncodeMimeType)"
        if let mimeType = MimeType.getType(forStr: contentType) {
            let encoder = try CoderFactory.encoder(for: mimeType)
            let encodedValue = try encoder.encode(@($"{param.VariableName}"))
            return encodedValue
        }

        throw DecodeError.unknownMimeType
    }
</text>
}
@EmptyLine
@if(Model.IsReturnTypeAnEnum()) {
<text>
    public override func returnFunc(data: Data) throws -> Decodable? {
        let contentType = "@(Model.DecodeMimeType)"
        if let mimeType = MimeType.getType(forStr: contentType) {
            let decoder = try CoderFactory.decoder(for: mimeType)
            let rawVal =  try decoder.decode(String.self, from: data)
            return @($"{Model.MethodReturnTypeDecodable}")(rawValue: rawVal)
        }

        throw DecodeError.unknownMimeType
    }

    public func execute(client: RuntimeClient, 
        completionHandler: @@escaping (@($"{Model.MethodReturnType}"), Error?) -> Void) -> Void {
        client.@($"{Model.GetExecuteCommandName()}")(command: self) {
            (result: @($"{Model.MethodReturnTypeDecodable}"), error: Error?) in
            completionHandler(result, error)
        } 
    }    
</text>
}
else if (!"void".Equals(Model.MethodReturnType, StringComparison.OrdinalIgnoreCase))
{
<text>
    public override func returnFunc(data: Data) throws -> Decodable? {
        let contentType = "@(Model.DecodeMimeType)"
        if let mimeType = MimeType.getType(forStr: contentType) {
            let decoder = try CoderFactory.decoder(for: mimeType)
            return try decoder.decode(@($"{Model.MethodReturnTypeDecodable}").self, from: data)
        }

        throw DecodeError.unknownMimeType
    }

    public func execute(client: RuntimeClient, 
        completionHandler: @@escaping (@($"{Model.MethodReturnType}"), Error?) -> Void) -> Void {
        client.@($"{Model.GetExecuteCommandName()}")(command: self) {
            (result: @($"{Model.MethodReturnTypeDecodable}"), error: Error?) in
            completionHandler(result, error)
        } 
    }
</text>
}else {
<text>
    public func execute(client: RuntimeClient,
        completionHandler: @@escaping (Error?) -> Void) -> Void {
        client.@($"{Model.GetExecuteCommandName()}")(command: self) {
            (error) in
            completionHandler(error)
        } 
    }
</text>
}
}